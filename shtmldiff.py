#! python

"""shtmldiff.py: Show changes between two text files using html side-by-side diff."""

# Usage: shtmldiff [OPTION]... FILE1 FILE2
#   Try `shtmldiff --help` for more information.

# Copyright (C) 2016-21 David Ireland <www.di-mgt.com.au/contact/>
# Written in Python specifically for Windows OS.
# Requires: `wdiff.exe` and `diff.exe`

# Derived from `rfcdiff` v1.45:
#  <http://www.tools.ietf.org/tools/rfcdiff/>
#  Copyright 2002 Henrik Levkowetz
#  and released under the same license conditions (see below).

# Differences from `rfcdiff`:
#  Rewritten from bash/awk to Python 2.7. (v1.3 => Python 3)
#  Uses Windows-specific stuff like double quotes (") for command lines instead of Linux (')
#  Outputs only the side-by-side .html output without any of the RFC-specific processing.
#  Output is HTML5 conformant.
#  CSS styles modified to use a more specific class
#  Always uses `wdiff` to compare differences on a word-by-word basis. This:
#    -- removes the need for a separate `worddiff` function
#    -- removes the need for a `fixesc` function to deal with split entities like `$amp;`
#  Fixed line numbering when lines are broken.
#  Added a pilcrow symbol (U+00B6, &para;) to show explicitly added or deleted blank lines.
#  Added extra options and changed some defaults to suit our own preferences.
#  [v1.1] Changed file mode to binary to force Unix-style LF line endings.
#  [v1.2] Added --latin1 option for iso-8859-1 charset (removed in v1.3)
#  [v1.3] 2021-01-20 Converted to Python 3. Detect input file encoding. Output always UTF-8.

import re
import os
import sys
import subprocess
import tempfile
# import linecache
import argparse

__version__ = "1.3"

__copyright__ = """\
    Copyright (C) 2016-21 David Ireland, DI Management Services Pty Ltd
    <www.di-mgt.com.au/contact/>.
    Based on `rfcdiff` by Henrik Levkowetz <https://tools.ietf.org/tools/rfcdiff/>.
"""

__license__ = __copyright__ + """\
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
"""


contact_email = 'https://www.di-mgt.com.au/side-by-side-html-diff-for-windows.html'

# GLOBAL OPTIONS: initial hard-coded defaults.
g_optwidth = 0
g_opttabstop = 8
g_optlinenum = True
g_optdebug = 0
g_charset = 'utf-8'

# CONSTANTS
BLANK = ('    <tr><td class="lineno"></td>'
         '<td>&nbsp;</td>'
         '<td>&nbsp;</td>'
         '<td>&nbsp;</td>'
         '<td class="lineno"></td></tr>\n')
NSPREAD = 150  # Number of chars in final line to spread out the table


def DBGPRINT(level, msg):
    """Print debugging message to stderr if `level` is at least
    equal to value of global var `g_optdebug`, else do nothing."""
    if level <= g_optdebug:
        sys.stderr.write(msg + "\n")


# HTML STUFF...
# output charset is _always_ UTF-8
def html_header():
    return """\
<!DOCTYPE html>
<html>
<head>
<meta charset="%s">
<!-- Generated by shtmldiff.py %s \n%s -->
""" % ('UTF-8', __version__, contact_email)


def html_style():
    # Modified from original by adding diff subclass of table
    return """\
<style>
  body    { margin: 0.4ex; margin-right: auto; }
  table.diff   { border:0px; border-collapse:collapse;}
  table.diff tr { }
  table.diff td { padding: 0; white-space: pre; font-family: monospace; vertical-align: top; font-size: 0.86em;}
  table.diff th { padding: 0; font-size: 0.86em; }
  .diff .left   { background-color: #EEE; }
  .diff .right  { background-color: #FFF; }
  .diff .lblock { background-color: #BFB; }
  .diff .rblock { background-color: #FF8; }
  .diff .insert { background-color: #8FF; }
  .diff .delete { background-color: #ACF; }
  .diff .title  { background-color: orange; }
  .diff .skip   { background-color: lightgray; font-size: 0.9em; }
  .diff .lineno { color: red; background-color: #FFF; font-size: 0.7em; text-align: right; padding: 0 2px; }
  .diff .stats, .stats td, .stats th { background-color: #EEE; padding: 2px 0; }
</style>
"""


def html_start():
    return """\
</head>
<body>
  <table class="diff">
"""


def html_end():
    return """\
  </table>
</body>
</html>
"""


def htmlesc(s):
    s = s.replace('&', '&amp;')
    s = s.replace('<', '&lt;')
    s = s.replace('>', '&gt;')
    return s


def numdisplay(n):
    return str(n) if g_optlinenum else ""


def linediff(s1, s2):
    """Return (prefix, w1, w2, suffix) where
    `s1 = prefix + w1 + suffix` and
    `s2 = prefix + w2 + suffix`."""

    len1, len2 = len(s1), len(s2)

    # Find length of common prefix
    plen = 0
    while (plen < len1 and plen < len2 and s1[plen] == s2[plen]):
        plen += 1

    # Find length of common suffix
    slen = 0
    while (slen < len1 - plen and slen < len2 - plen and s1[-slen - 1] == s2[-slen - 1]):
        slen += 1

    # Form parts
    prefix = s1[:plen]
    suffix = s1[len1 - slen:]
    w1 = s1[plen:len1 - slen]
    w2 = s2[plen:len2 - slen]

    # Check valid
    assert(s1 == prefix + w1 + suffix)
    assert(s2 == prefix + w2 + suffix)

    return(prefix, w1, w2, suffix)


def form_outbase(base1, base2):
    """Return output filename formed from common prefix joined descriptively."""
    # Note order here is 2,1
    (prefix, w1, w2, suffix) = linediff(base2, base1)
    if len(w2) > 0:
        outbase = "%s%s-from-%s.diff.html" % (prefix, w1, w2)
    else:
        outbase = "%s%s.diff.html" % (prefix, w1)
    return outbase


def run_command(cmdline, okcode):
    """Get the output from running a system command and deal with nonzero return code."""
    try:
        result = subprocess.check_output(cmdline)
    except subprocess.CalledProcessError as e:
        # expecting returncode == okcode for correct outcome
        # -- check_output() fails if returncode is nonzero, so we catch it here
        result = e.output
        if e.returncode != okcode:
            name = cmdline.partition(' ')[0]
            raise RuntimeError("Command '" + name + "' returned unexpected exit status: " + str(e.returncode))
    except OSError as e:
        # catch missing exe
        name = cmdline.partition(' ')[0]
        raise OSError("'" + name + "' failed: " + str(e))
    return result


def chunkdiff(stack1, stack2):
    """Convert input stacks of unified `diff` lines into stacks of `wdiff` output
    with html mark up to show inserts and deletions."""

    # 1. Write out stacks to two temporary files
    # -- we need to keep the files after closing and we need their names for wdiff
    (osp1, name1) = tempfile.mkstemp(prefix="shd-")
    (osp2, name2) = tempfile.mkstemp(prefix="shd-")
    DBGPRINT(1, "TMPFILE1=" + name1)
    DBGPRINT(1, "TMPFILE2=" + name2)
    f1 = os.fdopen(osp1, "w+", encoding=g_charset)
    f2 = os.fdopen(osp2, "w+", encoding=g_charset)

    while (len(stack1) > 0):
        s = stack1.pop(0)
        DBGPRINT(2, "S1=[" + repr(s) + "]")
        f1.write(s + "\n")
    while (len(stack2) > 0):
        s = stack2.pop(0)
        DBGPRINT(2, "S2=[" + repr(s) + "]")
        f2.write(s + "\n")
    f1.close()
    f2.close()

    # 2. Call wdiff twice for left and right sides
    cmd1 = """wdiff -n -2 -w "<span class='delete'>" -x "</span>" %s %s""" % (name1, name2)
    DBGPRINT(2, "CMD1=[" + cmd1 + "]")
    wd1 = run_command(cmd1, 1).decode(g_charset)
    DBGPRINT(3, "WDIFF1=[" + repr(wd1) + "]")
    cmd2 = """wdiff -n -1 -y "<span class='insert'>" -z "</span>" %s %s""" % (name1, name2)
    DBGPRINT(2, "CMD2=[" + cmd2 + "]")
    wd2 = run_command(cmd2, 1).decode(g_charset)
    DBGPRINT(3, "WDIFF2=[" + repr(wd2) + "]")

    # TRICKY-BIT: wdiff for Windows adds CR-LF pairs to the end of each line.
    # We don't want the last one at all, and we want the middle ones replace by LF
    # so our line split using CRs below will work.
    # Strip exactly one CR-LF from end.
    wd1 = wd1[:-2] if wd1.endswith("\r\n") else wd1
    wd2 = wd2[:-2] if wd2.endswith("\r\n") else wd2
    # and change any others to a single LF
    wd1 = wd1.replace("\r\n", "\n")
    wd2 = wd2.replace("\r\n", "\n")
    DBGPRINT(3, "WDIFF1=[" + repr(wd1) + "]")
    DBGPRINT(3, "WDIFF2=[" + repr(wd2) + "]")

    # 3. Re-write results line-by-line back to (now empty) stacks
    L1 = wd1.split("\n")
    for line in L1:
        DBGPRINT(3, repr(line))
        stack1.insert(0, line)

    L2 = wd2.split("\n")
    for line in L2:
        DBGPRINT(3, repr(line))
        stack2.insert(0, line)

    # 4. Delete the temp files
    os.remove(name1)
    os.remove(name2)


def flush(fo, stack1, stack2, linenum1, linenum2):
    """Flush the stacks."""
    DBGPRINT(2, "Flushing stacks of lengths: " + repr((len(stack1), len(stack2))))

    if (len(stack1) == 0 and len(stack2) == 0):
        return (linenum1, linenum2)

    if (len(stack1) > 0 and len(stack2) > 0):
        # Common blocks - use wdiff
        chunkdiff(stack1, stack2)
        DBGPRINT(2, "After chunkdiff, stack lengths: " + repr((len(stack1), len(stack2))))
        while (len(stack1) > 0 and len(stack2) > 0):
            # These lines now contain the marked up HTML
            left = stack1.pop()
            right = stack2.pop()
            # Replace CR's we used as breaklines with proper newlines
            left = left.replace("\r", "\n")
            right = right.replace("\r", "\n")

            sout = ('    <tr><td class="lineno">' + numdisplay(linenum1) + '</td>'
                    '<td class="lblock">' + left + '</td>'
                    '<td>&nbsp;</td>'
                    '<td class="rblock">' + right + '</td>'
                    '<td class="lineno">' + numdisplay(linenum2) + '</td></tr>\n')
            fo.write(sout)
            linenum1 += 1
            linenum2 += 1

        while (len(stack1) > 0):
            s = stack1.pop()
            if len(s) == 0:  # Show deleted blank line with a pilcrow symbol
                s = '<span class="delete">&para;</span>'
            sout = ('    <tr><td class="lineno">' + numdisplay(linenum1) + '</td>'
                    '<td class="lblock">' + s + '</td>'
                    '<td>&nbsp;</td>'
                    '<td class="rblock">&nbsp;</td>'
                    '<td class="lineno">&nbsp;</td></tr>\n')
            fo.write(sout)
            linenum1 += 1

        while (len(stack2) > 0):
            s = stack2.pop()
            if len(s) == 0:  # Show added blank line with a pilcrow symbol
                s = '<span class="insert">&para;</span>'
            sout = ('    <tr><td class="lineno">&nbsp;</td>'
                    '<td class="lblock">&nbsp;</td>'
                    '<td>&nbsp;</td>'
                    '<td class="rblock">' + s + '</td>'
                    '<td class="lineno">' + numdisplay(linenum2) + '</td></tr>\n')
            fo.write(sout)
            linenum2 += 1

    else:   # One side or the other is empty
        while (len(stack1) > 0):
            s = stack1.pop(0)
            if len(s) == 0:
                s = "&para;"
            sout = ('    <tr><td class="lineno">' + numdisplay(linenum1) + '</td>'
                    '<td class="lblock"><span class="delete">' + s + '</span></td>'
                    '<td>&nbsp;</td>'
                    '<td class="rblock">&nbsp;</td>'
                    '<td class="lineno">&nbsp;</td></tr>\n')
            fo.write(sout)
            linenum1 += 1

        while (len(stack2) > 0):
            s = stack2.pop(0)
            if len(s) == 0:
                s = "&para;"
            sout = ('    <tr><td class="lineno">&nbsp;</td>'
                    '<td class="lblock">&nbsp;</td>'
                    '<td>&nbsp;</td>'
                    '<td class="rblock"><span class="insert">' + s + '</span></td>'
                    '<td class="lineno">' + numdisplay(linenum2) + '</td></tr>\n')
            fo.write(sout)
            linenum2 += 1

    return (linenum1, linenum2)


def maybebreakline(s):
    """Process raw input line: expand tabs, escape HTML chars,
    and break it if too long."""
    s = s.replace("\r", "")
    s = s.expandtabs(g_opttabstop) if g_opttabstop > 0 else s
    newline = ''
    # Break lines using CR - we will replace later
    # and avoid incrementing linenumber
    if (g_optwidth > 0):
        while (len(s) > g_optwidth):
            newline += htmlesc(s[0:g_optwidth]) + "\r"
            s = s[g_optwidth:]
    return newline + htmlesc(s)


def find_encoding(data):
    """Try to find character encoding given __binary__ data."""
    encod = None
    encodings = ['utf-8', 'iso-8859-1']
    for e in encodings:
        try:
            s = data.decode(encoding=e)
        except UnicodeDecodeError:
            # print('got unicode error with %s , trying different encoding' % e)
            pass
        else:
            encod = e
            # print('found valid encoding:  %s ' % e)
            break
    return encod


def main():

    # Parse command line arguments
    #   Usage: shtmldiff [OPTION]... FILE1 FILE2
    #   If FILE1 or FILE2 is `-', read standard input.
    #   Try `shtmldiff.py --help` for more information.
    parser = argparse.ArgumentParser(prefix_chars='-+',
                                     description='A side-by-side html diff program',
                                     epilog="If file1 or file2 is `-`, read standard input.")
    parser.add_argument('-v', '--version', action='version', version='%(prog)s ' + __version__)
    parser.add_argument('-L', '--license', action='version', version='%(prog)s ' + __version__ + ': ' + __license__,
                        help='show licence and exit')
    parser.add_argument('-w', '--width', default=0, type=int,
                        help='set maximum width in characters for each half of display (default=no max)')
    parser.add_argument('+l', '--linenum', action='store_true', default=True,
                        help='show linenumbers for each line  (default)')
    parser.add_argument('-l', '--no-linenum', action='store_true',
                        help='do not show linenumbers for each line')
    parser.add_argument('+b', '--browse', action='store_true', default=True,
                        help='show html output in browser (default)')
    parser.add_argument('-b', '--no-browse', action='store_true',
                        help='do not show html output in browser')
    parser.add_argument('-t', '--tabstop', default=8, type=int,
                        help='set tabstop for expanding tabs to spaces (default=8)')
    parser.add_argument('-i', '--ignore-case', action='store_true',
                        help='consider upper- and lower-case to be the same')
    parser.add_argument('-s', '--ignore-space-change', action='store_true',
                        help='ignore changes in the amount of white space')
    parser.add_argument('-a', '--ignore-all-space', action='store_true',
                        help='ignore all white space')
    parser.add_argument('-f', '--filename', default=None,
                        help='specify filename for html output (default=`file2-from-1.diff.html`)')
    parser.add_argument('--stdout', action='store_true', default=False,
                        help='send output to stdout instead of to a file')
    parser.add_argument('-d', action='count', default=0,
                        help='print debugging output to stderr, `-dd` show more')

    # After options, expect exactly 2 arguments
    parser.add_argument("file1")
    parser.add_argument("file2")

    # Process command-line arguments
    args = parser.parse_args()
    file1 = args.file1
    file2 = args.file2

    # Global options
    global g_opttabstop, g_optwidth, g_optlinenum, g_optdebug, g_charset
    g_opttabstop = args.tabstop
    g_optwidth = args.width
    g_optlinenum = args.linenum and not args.no_linenum
    g_optdebug = args.d

    # Local options - only used in main()
    optbrowser = args.browse and not args.no_browse
    optfilename = args.filename
    optstdout = args.stdout

    DBGPRINT(1, repr(args))
    DBGPRINT(1, "CWD:" + os.getcwd())

    # Setup extra options for diff
    xopts = ''
    xopts += '-i ' if args.ignore_case else ''
    xopts += '-b ' if args.ignore_space_change else ''
    xopts += '-w ' if args.ignore_all_space else ''
    DBGPRINT(1, "xopts=[" + xopts + "]")

    # NOW DO THE BUSINESS...
    # Create a diff file from the two input files
    # Careful: `diff` returns 0 if no differences, 1 for usual diffs and 2 for trouble
    # but subprocess.check_output() fails if returncode is not zero, so we must catch it
    diffdata = run_command('diff -Bd -U 10 ' + xopts + ' "' + file1 + '" "' + file2 + '"', 1)
    DBGPRINT(3, "diffdata:\n" + str(diffdata))

    # Catch no diffs
    if len(diffdata) == 0:
        print("No differences found")
        return

    # Try and figure out char encoding
    g_charset = find_encoding(diffdata)
    if g_charset is None:
        print("ERROR: Unknown character encoding.")
        return

    # Write diffdata to a temp file (binary)
    f = tempfile.TemporaryFile(mode='w+b')
    f.write(diffdata)
    f.seek(0)

    # Check we have a file in the correct format. e.g.:
    # --- lao.txt    Sun May 01 05:36:36 2016
    # +++ tzu.txt    Sun May 01 05:37:08 2016

    line = f.readline().decode(g_charset)
    DBGPRINT(3, "Line1: " + line)
    if not re.match('---', line):
        raise Exception('Expected input to be unified diff format')

    leftfile = re.match(r'--- (.+)\t', line).groups()[0]
    line = f.readline().decode(g_charset)
    DBGPRINT(3, "Line2: " + line)

    if not re.match(r'\+\+\+', line):
        raise Exception('Expected unified diff format')
    rightfile = re.match(r'\+\+\+ (.+)\t', line).groups()[0]

    # Compose title for html: "Diff: file1 - file2"
    # Use basenames unless both are the same
    # in which case use full paths
    if os.path.basename(leftfile) != os.path.basename(rightfile):
        leftbase = os.path.basename(leftfile)
        rightbase = os.path.basename(rightfile)
    else:
        (leftbase, rightbase) = (leftfile, rightfile)

    # Compose name for output file
    if (optfilename):
        outfile = optfilename
    else:
        base1 = os.path.basename(leftfile)
        base2 = os.path.basename(rightfile)
        outfile = form_outbase(base1, base2)

    # Start writing output HTML file (always UTF-8)
    fo = open(outfile, "w", encoding='utf-8') if not optstdout else sys.stdout

    fo.write(html_header())
    fo.write("<title>Diff: %s - %s</title>\n" % (leftbase, rightbase))
    fo.write(html_style())
    fo.write(html_start())

    sout = ('    <tr class="title"><th></th>'
            '<th>&nbsp;' + leftbase + '&nbsp;</th><th>&nbsp;</th>'
            '<th>&nbsp;' + rightbase + '&nbsp;</th><th></th></tr>\n')
    fo.write(sout)

    nchunks = 0
    diffcount1 = 0
    diffcount2 = 0
    # Stacks to store lines in a chunk
    stack1 = []
    stack2 = []
    # These line numbers will be reset by the first chunk header
    linenum1 = 1
    linenum2 = 1

    # Read line-by-line
    for line in f:
        line = line.decode(g_charset).rstrip("\r\n")    # chomp

        # [We could precompute regexes here, but they're
        # automatically cached anyway
        # and this way makes the code easier to read.]

        # Five cases:
        if (re.match(r'@@', line)):
            nchunks += 1
            DBGPRINT(3, " >>Found start of chunk:" + line)

            # From Guido's blog <http://www.artima.com/weblogs/viewpost.jsp?thread=164293>:
            # Expecting format '@@ -' range ' +' range ' @@'
            # where range is either one unsigned decimal number or two separated by a comma
            # The first number is the start line of the chunk in the old or new file.
            # The second number is chunk size in that file; it and the comma are omitted if the chunk size is 1.
            # We only need the two start numbers.
            results = re.search(r'-(\d+)(?:,\d+)? \+(\d+)(?:,\d+)?', line)
            if not results:
                raise Exception('Invalid format for start of chunk')
            results = [int(i) for i in results.groups()]
            (linenum1, linenum2) = results
            DBGPRINT(1, "Starting a new block with line nums=" + repr((linenum1, linenum2)))
            # Output a "skipping" row, unless first time
            if (linenum1 > 1 or linenum2 > 1):
                # Blank line first
                sout = BLANK
                fo.write(sout)
                # Then a grey "skipping" line
                sout = ('    <tr class="skip"><td>&nbsp;</td>'
                        '<th>skipping to change at <em>line '
                        + numdisplay(linenum1) + '</em></th><th>&nbsp;</th>'
                        '<th>skipping to change at <em>line ' + numdisplay(linenum2)
                        + '</em></th><td></td></tr>\n')
                fo.write(sout)

        elif (re.match(r' ', line)):
            DBGPRINT(3, " >>Found common:" + line[1:])
            # Flush all the different lines we've saved, then write this one
            (linenum1, linenum2) = flush(fo, stack1, stack2, linenum1, linenum2)
            s = line[1:]
            s = maybebreakline(s)
            sout = ('    <tr><td class="lineno">' + numdisplay(linenum1) + '</td>'
                    '<td class="left">' + s + '</td>'
                    '<td>&nbsp;</td>'
                    '<td class="right">' + s + '</td>'
                    '<td class="lineno">' + numdisplay(linenum2) + '</td></tr>\n')
            fo.write(sout)
            linenum1 += 1
            linenum2 += 1

        elif (re.match(r'-', line)):
            DBGPRINT(3, " >>Found delete:" + line[1:])
            diffcount1 += 1
            s = line[1:]
            s = maybebreakline(s)
            stack1.append(s)

        elif (re.match(r'\+', line)):
            DBGPRINT(3, " >>Found insert:" + line[1:])
            diffcount2 += 1
            s = line[1:]
            s = maybebreakline(s)
            stack2.append(s)

        # (later, maybe) '\ No newline at end of file'

    # Flush any remaining stacks
    (linenum1, linenum2) = flush(fo, stack1, stack2, linenum1, linenum2)

    # Insert a last blank line
    sout = BLANK
    fo.write(sout)

    # End of changes line
    sout = ('    <tr class="skip"><th colspan="5">'
            '&nbsp;End of changes. ' + str(nchunks) + ' change block'
            + ('s' if nchunks > 1 else '') + '.&nbsp;</th></tr>\n')
    fo.write(sout)

    # Statistics line
    sout = ('<tr class="stats"><td></td>'
            '<th><i>' + str(diffcount1) + ' lines changed or deleted</i></th>'
            '<th></th>'
            '<th><i>' + str(diffcount2) + ' lines changed or added</i></th>'
            '<td></td></tr>')
    fo.write(sout)

    # And a final line to spread out the table
    sout = ('    <tr><th colspan="5">' + '&nbsp;' * NSPREAD + '</th></tr>\n')
    fo.write(sout)

    fo.write(html_end())

    # Close files
    fo.close()
    f.close()

    # Open the browser (Windows only?)
    if optbrowser and not optstdout:
        os.startfile(outfile)

    DBGPRINT(1, "Success, created file: '" + outfile + "'")


if __name__ == "__main__":
    main()
